<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Task Force: Eclipse — by Mizzery</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #11192e;
      --accent: #3bd1ff;
      --accent-2: #7cff6b;
      --danger: #ff5c5c;
      --text: #e6f0ff;
      --muted: #93a4c1;
    }
    html, body { margin: 0; height: 100%; background: radial-gradient(1000px 600px at 70% 30%, #0f1731, var(--bg)); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; color: var(--text); overflow: hidden; }
    .hud { position: fixed; inset: 0; pointer-events: none; }
    .panel { position: absolute; left: 16px; top: 16px; background: #0f1935aa; border: 1px solid #2a355b; border-radius: 12px; padding: 10px 12px; backdrop-filter: blur(4px); font-size: 12px; color: var(--muted); }
    .panel h3 { margin: 0 0 6px 0; color: var(--text); font-size: 13px; letter-spacing: .08em; text-transform: uppercase }
    .panel .row { display: grid; grid-template-columns: auto 1fr; gap: 8px 12px; align-items: center }
    .bar { height: 6px; background: #1a2240; border-radius: 999px; overflow: hidden; box-shadow: inset 0 0 0 1px #2a355b; }
    .bar > span { display: block; height: 100% }
    .hp { background: linear-gradient(90deg, #38ef7d, #3a86ff); }
    .noise { background: linear-gradient(90deg, #ffb703, #fb8500); }

    .center { position: absolute; inset: 0; display: grid; place-items: center; background: radial-gradient(1000px 700px at 50% -10%, #16224a, transparent); }
    .card { width: min(820px, 92vw); background: #0f1935e6; border: 1px solid #304071; border-radius: 18px; padding: 22px; box-shadow: 0 10px 40px #00000088; }
    .title { font-weight: 800; font-size: clamp(24px, 2.4vw + 16px, 42px); letter-spacing: .06em; text-transform: uppercase; margin: 0 0 8px; }
    .subtitle { color: var(--muted); margin: 0 0 18px; }
    .btns { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 12px; }
    button { pointer-events: auto; cursor: pointer; border: 1px solid #41508a; background: linear-gradient(180deg, #18234a, #0f1a36); color: var(--text); padding: 10px 14px; border-radius: 12px; font-weight: 700; letter-spacing: .04em; text-transform: uppercase; transition: transform .08s ease, box-shadow .2s ease; }
    button:hover { box-shadow: 0 0 0 1px #5a75bf, 0 10px 30px #0006; }
    button:active { transform: translateY(1px) scale(.99); }

    .toast { position: absolute; right: 16px; bottom: 16px; background: #0f1935e6; border: 1px solid #304071; padding: 10px 12px; border-radius: 12px; font-size: 12px; color: var(--muted); }
    a { color: var(--accent); text-decoration: none }

    #gameWrap { position: fixed; inset: 0; display: grid; place-items: center; }
    canvas { box-shadow: 0 10px 50px #0008; border-radius: 14px; border: 1px solid #273663; background: #0a0f20; }

    .minimap { position: absolute; right: 16px; top: 16px; background: #0f1935aa; border: 1px solid #2a355b; border-radius: 10px; padding: 6px; width: 140px; height: 140px; }

    .legend { position: absolute; left: 16px; bottom: 16px; font-size: 12px; color: var(--muted); background: #0f1935cc; border: 1px solid #2a355b; border-radius: 10px; padding: 8px 10px; }
    .legend code { color: var(--text); background: #0b1230; border-radius: 6px; padding: 2px 6px; border: 1px solid #1f2a55; }

    .extract { position: absolute; top: 16px; left: 50%; transform: translateX(-50%); background: #0f1935e6; border: 1px solid #304071; border-radius: 12px; padding: 8px 12px; font-size: 12px; color: var(--muted); display: none; }
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="game" width="1000" height="600" tabindex="0"></canvas>
  </div>

  <div class="hud">
    <div class="panel" style="min-width:260px">
      <h3>Task Force: Eclipse</h3>
      <div class="row"><div>Health</div><div class="bar"><span id="hpBar" class="hp" style="width:100%"></span></div></div>
      <div class="row"><div>Noise</div><div class="bar"><span id="noiseBar" class="noise" style="width:0%"></span></div></div>
      <div class="row"><div>Intel</div><div id="intelText">0 / 1</div></div>
      <div class="row"><div>Enemies</div><div id="enemyText">–</div></div>
      <div class="row"><div>Weapon</div><div id="weaponText">–</div></div>
      <div class="row"><div>Ammo</div><div id="ammoText">–</div></div>
      <div class="row"><div>Reload</div><div class="bar"><span id="reloadBar" style="width:0%"></span></div></div>
    </div>

    <div class="minimap"><canvas id="mini" width="128" height="128"></canvas></div>
    <div class="legend">Controls: <code>WASD</code> move · <code>Mouse</code> aim · <code>LMB</code> shoot · <code>E</code> interact · Controller supported (sticks + RT + A)</div>
    <div id="extractMsg" class="extract">Extraction available! Reach the green zone.</div>

    <div id="menu" class="center">
      <div class="card">
        <h1 class="title">Task Force: Eclipse</h1>
        <h2 class="subtitle">By Mizzery</h2>
        <p class="subtitle">Top‑down tactical raid. Secure the <strong>Intel Drive</strong>, avoid patrols, and extract alive. Enemies adapt to your noise and tactics.</p>
        <div class="btns">
          <button id="startBtn">New Operation</button>
          <button id="howBtn">How to Play</button>
          <button id="gpBtn">Detect Controller</button>
        </div>
        <p style="margin-top:12px; color:var(--muted); font-size:12px">Beta v0.1 © Mizzery 2025.</p>
      </div>
    </div>

    <div id="toast" class="toast" style="display:none"></div>
  </div>

  <script>
  ;(() => {
    // ================== SAFETY: GLOBAL ERROR TOAST ==================
    window.addEventListener('error', (e)=>{
      const el = document.getElementById('toast');
      if (!el) return;
      el.textContent = 'JS Error: ' + (e.message||'unknown');
      el.style.display = 'block';
      clearTimeout(el._t);
      el._t = setTimeout(()=> el.style.display='none', 5000);
    });

    const TAU = Math.PI * 2;

    // ================== UTILITIES ==================
    const rand = (a,b) => a + Math.random()*(b-a);
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const dist = (a,b) => Math.hypot(a.x-b.x, a.y-b.y);
    const lineOfSight = (from, to, walls) => {
      const steps = 20; const dx = (to.x - from.x)/steps; const dy = (to.y - from.y)/steps;
      let x = from.x, y = from.y;
      for (let i=0;i<steps;i++){ x += dx; y += dy; for (const w of walls){ if (x> w.x && x< w.x+w.w && y> w.y && y< w.y+w.h) return false; } }
      return true;
    };

    // ================== PROC-GEN HELPERS ==================
    function makeRNG(seed){
      // Mulberry32
      let t = seed >>> 0;
      return function(){
        t += 0x6D2B79F5;
        let r = Math.imul(t ^ (t >>> 15), 1 | t);
        r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
        return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
      }
    }
    function randi(rng, a, b){ return Math.floor(a + rng() * (b - a + 1)); }
    function randf(rng, a, b){ return a + rng() * (b - a); }
    function rect(x,y,w,h){ return {x,y,w,h}; }
    function rectsOverlap(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
    function pointInRect(px,py,rc){ return px>rc.x && px<rc.x+rc.w && py>rc.y && py<rc.y+rc.h; }
    function rectInAny(walls, r){ for (const w of walls){ if (rectsOverlap(w,r)) return true; } return false; }
    function pointInAny(walls, x,y){ for (const w of walls){ if (pointInRect(x,y,w)) return true; } return false; }

    function generateLevelLayout(){
      const walls = [];
      const safeStart = rect(0, H/2 - 140, 280, 280); // keep spawn/extract area clear
      // Place 12–18 random walls (either long horizontal or vertical slabs)
      const seed = (Date.now() % 2147483647);
      const rng = makeRNG(seed);
      const count = randi(rng, 12, 18);
      for (let i=0;i<count;i++){
        const vertical = rng() < 0.5;
        const thick = randi(rng, 30, 60);
        const len = randi(rng, 250, 460);
        const x = randi(rng, 200, state.world.w - 200);
        const y = randi(rng, 80, state.world.h - 80);
        const w = vertical ? thick : len;
        const h = vertical ? len : thick;
        const candidate = rect(x - (w>>1), y - (h>>1), w, h);
        if (candidate.x < 0 || candidate.y < 0 || candidate.x + candidate.w > state.world.w || candidate.y + candidate.h > state.world.h) { i--; continue; }
        if (rectsOverlap(candidate, safeStart)) { i--; continue; }
        // avoid heavy overlap with existing walls
        let bad = false;
        for (const w2 of walls){
          const areaOverlap = Math.max(0, Math.min(candidate.x+candidate.w, w2.x+w2.w) - Math.max(candidate.x, w2.x)) * Math.max(0, Math.min(candidate.y+candidate.h, w2.y+w2.h) - Math.max(candidate.y, w2.y));
          const areaCand = candidate.w * candidate.h; if (areaOverlap > 0.35 * areaCand){ bad = true; break; }
        }
        if (bad) { i--; continue; }
        walls.push(candidate);
      }

      // Choose intel position far from start and not inside walls
      let intel = {x: state.world.w - 250, y: randi(rng, 160, state.world.h-160), r:12, taken:false};
      for (let t=0; t<80; t++){
        const ix = randi(rng, Math.floor(state.world.w*0.55), state.world.w-100);
        const iy = randi(rng, 120, state.world.h-120);
        if (!pointInAny(walls, ix, iy)) { intel.x=ix; intel.y=iy; break; }
      }

      return { walls, intel };
    }

    function toast(msg, ms=2000){ const el = document.getElementById('toast'); if(!el) return; el.textContent=msg; el.style.display='block'; clearTimeout(el._t); el._t=setTimeout(()=>el.style.display='none', ms); }

    // ================== GAME STATE ==================
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const mini = document.getElementById('mini');
    const mctx = mini.getContext('2d');
    const W = canvas.width, H = canvas.height;

    const state = {
      running:false, t:0, dt:0, last:0,
      keys: new Set(), mouse:{x:0,y:0,down:false},
      gp:null,
      world:{ w: 2200, h: 1400 },
      camera:{ x:0, y:0, zoom:1 },
      player:null, bullets:[], enemies:[], walls:[], intel:null, extractZone:null,
      noise:0, won:false, lost:false,
      weapons:[
        { key:'AR', name:'AR-9', rpm:600, dmg:28, mag:30, reserve:90, reload:1.9, spread:0.035, speed:900 },
        { key:'SMG', name:'Viper SMG', rpm:900, dmg:20, mag:40, reserve:160, reload:1.6, spread:0.055, speed:950 },
        { key:'DMR', name:'DMR-7', rpm:300, dmg:45, mag:15, reserve:45, reload:2.2, spread:0.012, speed:1100 }
      ],
      weaponIndex:0
    };

    function setupLevel(){
      state.bullets.length=0; state.enemies.length=0; state.walls.length=0; state.won=false; state.lost=false; state.noise=0;
      state.player = { x: 200, y: H/2, r: 14, hp: 100, speed: 180, dir: 0, fireCd:0, hasIntel:false, reloading:false, reloadT:0, ammo:[] };
      state.player.ammo = state.weapons.map(w=>({mag:w.mag, reserve:w.reserve}));
      state.weaponIndex = 0; updateWeaponHud();

      // --- Procedural layout ---
      const {walls, intel} = generateLevelLayout();
      state.walls.push(...walls);
      state.intel = intel;

      // Extraction zone near start (always clear by generator)
      state.extractZone = { x: 120, y: H/2 - 60, w: 160, h: 120, active:false };

      // Spawn enemies in free spaces (prefer near intel)
      const makeEnemy = (x,y)=>({ x,y, r:12, hp:60, speed:120, state:'patrol', target:null, fireCd:0, angle:0, fov:Math.PI*0.8, viewDist:300, hear: 200 });
      const enemyCount = 10 + Math.floor(Math.random()*6);
      let tries = 0;
      while (state.enemies.length < enemyCount && tries < 300){
        tries++;
        const ex = intel.x + Math.floor((Math.random()-0.5)*600);
        const ey = intel.y + Math.floor((Math.random()-0.5)*600);
        if (ex<40||ey<40||ex>state.world.w-40||ey>state.world.h-40) continue;
        if (pointInAny(state.walls, ex, ey)) continue;
        // keep some distance from player spawn
        if (Math.hypot(ex-200, ey-H/2) < 260) continue;
        state.enemies.push(makeEnemy(ex, ey));
      }

      document.getElementById('enemyText').textContent = state.enemies.length.toString();
      document.getElementById('intelText').textContent = `0 / 1`;
      document.getElementById('extractMsg').style.display = 'none';
    }

    // ================== INPUT ==================
    const downKeys = new Set();
    window.addEventListener('keydown', e=>{
      downKeys.add(e.code);
      if (["KeyW","KeyA","KeyS","KeyD","Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Digit1","Digit2","Digit3","KeyR"].includes(e.code)) e.preventDefault();
      if (e.code==='Digit1') setWeapon(0);
      if (e.code==='Digit2') setWeapon(1);
      if (e.code==='Digit3') setWeapon(2);
      if (e.code==='KeyR') startReload();
    });
    window.addEventListener('keyup', e=> downKeys.delete(e.code));
    state.keys = downKeys;

    canvas.addEventListener('wheel', (e)=>{ e.preventDefault(); if (e.deltaY>0) cycleWeapon(1); else cycleWeapon(-1); }, {passive:false});
    canvas.addEventListener('mousemove', e=>{ const r = canvas.getBoundingClientRect(); state.mouse.x = (e.clientX - r.left); state.mouse.y = (e.clientY - r.top); });
    canvas.addEventListener('mousedown', ()=> state.mouse.down = true);
    window.addEventListener('mouseup', ()=> state.mouse.down = false);

    window.addEventListener('gamepadconnected', (e)=>{ state.gp = e.gamepad.index; toast('Controller connected'); });
    window.addEventListener('gamepaddisconnected', ()=>{ state.gp=null; toast('Controller disconnected'); });
    function readGamepad(){ if (state.gp==null) return null; return navigator.getGamepads()[state.gp]; }

    // ================== PHYSICS / COLLISION ==================
    function moveWithColliders(obj, vx, vy){
      const tryMove = (dx,dy)=>{
        obj.x += dx; obj.y += dy;
        for (const w of state.walls){ if (obj.x> w.x-obj.r && obj.x< w.x+w.w+obj.r && obj.y> w.y-obj.r && obj.y< w.y+w.h+obj.r){
            if (dx>0) obj.x = w.x-obj.r; if (dx<0) obj.x = w.x+w.w+obj.r; if (dy>0) obj.y = w.y-obj.r; if (dy<0) obj.y = w.y+w.h+obj.r;
        }}
        obj.x = clamp(obj.x, obj.r, state.world.w-obj.r); obj.y = clamp(obj.y, obj.r, state.world.h-obj.r);
      };
      tryMove(vx*state.dt, 0); tryMove(0, vy*state.dt);
    }

    // ================== ENEMY AI ==================
    function updateEnemy(e){
      const p = state.player; const toP = {x:p.x - e.x, y:p.y - e.y};
      const angToP = Math.atan2(toP.y, toP.x); const angDiff = Math.atan2(Math.sin(angToP - e.angle), Math.cos(angToP - e.angle));
      const see = (Math.abs(angDiff) < e.fov*0.5) && (Math.hypot(toP.x,toP.y) < e.viewDist) && lineOfSight(e, p, state.walls);
      const hear = (Math.hypot(toP.x,toP.y) < e.hear * (1 + state.noise*0.8));
      if (see || hear) { e.state = 'hunt'; e.target = {x:p.x, y:p.y}; }

      if (e.state==='patrol'){
        if (!e._patrol || Math.random()<0.01) e._patrol = { x: e.x + rand(-200,200), y: e.y + rand(-200,200) };
        const v = { x: e._patrol.x - e.x, y: e._patrol.y - e.y }; const d = Math.hypot(v.x,v.y);
        if (d>5){ e.angle = Math.atan2(v.y,v.x); moveWithColliders(e, Math.cos(e.angle)*e.speed*0.4, Math.sin(e.angle)*e.speed*0.4); }
      }

      if (e.state==='hunt'){
        const v = { x: p.x - e.x, y: p.y - e.y }; const d = Math.hypot(v.x,v.y);
        e.angle = Math.atan2(v.y,v.x);
        if (d>220) moveWithColliders(e, Math.cos(e.angle)*e.speed*0.7, Math.sin(e.angle)*e.speed*0.7);
        e.fireCd -= state.dt; if (d<420 && lineOfSight(e, p, state.walls) && e.fireCd<=0){ shootFrom(e, e.angle, false); e.fireCd = 0.9 + Math.random()*0.5; }
      }
    }

    // ================== WEAPONS / SHOOTING / RELOAD ==================
    function shootFrom(from, angle, friendly=true, weapon=null){
      const w = weapon || {speed:800, spread: friendly?0.035:0.06, dmg: friendly?32:15};
      const speed = w.speed; const spread = friendly ? (w.spread ?? 0.035) : 0.06; const dmg = friendly ? (w.dmg ?? 28) : 15;
      const a = angle + rand(-spread, spread);
      const b = { x: from.x + Math.cos(a)*from.r, y: from.y + Math.sin(a)*from.r, vx: Math.cos(a)*speed, vy: Math.sin(a)*speed, life: 0.9, dmg, friendly };
      state.bullets.push(b);
      state.noise = clamp(state.noise + (friendly? 0.15: 0.05), 0, 1);
    }

    function tryShoot(angle){
      const p = state.player; const w = state.weapons[state.weaponIndex]; const a = state.player.ammo[state.weaponIndex];
      if (p.fireCd>0) return;
      if (p.reloading && a.mag>0){ p.reloading=false; p.reloadT=0; }
      if (a.mag<=0){ startReload(); return; }
      shootFrom(p, angle, true, w);
      a.mag -= 1;
      p.fireCd = 60 / w.rpm;
      updateWeaponHud();
    }

    function updateWeaponHud(){
      const w = state.weapons[state.weaponIndex]; const a = state.player?.ammo?.[state.weaponIndex] || {mag:0,reserve:0};
      document.getElementById('weaponText').textContent = w.name;
      document.getElementById('ammoText').textContent = `${a.mag} / ${a.reserve}`;
      document.getElementById('reloadBar').style.width = state.player?.reloading ? '5%' : '0%';
    }
    function setWeapon(i){ state.weaponIndex = (i+state.weapons.length)%state.weapons.length; state.player.fireCd = 0; state.player.reloading=false; state.player.reloadT=0; updateWeaponHud(); }
    function cycleWeapon(d){ setWeapon(state.weaponIndex + d); }
    function startReload(){
      const w = state.weapons[state.weaponIndex]; const a = state.player.ammo[state.weaponIndex];
      if (state.player.reloading) return;
      if (a.mag>=w.mag) return;
      if (a.reserve<=0) { toast('No reserve ammo'); return; }
      state.player.reloading = true; state.player.reloadT = w.reload; document.getElementById('reloadBar').style.width = '1%';
    }
    function finishReload(){
      const w = state.weapons[state.weaponIndex]; const a = state.player.ammo[state.weaponIndex];
      const needed = w.mag - a.mag; const take = Math.min(needed, a.reserve);
      a.mag += take; a.reserve -= take;
      state.player.reloading=false; state.player.reloadT=0; document.getElementById('reloadBar').style.width = '0%'; updateWeaponHud();
    }

    function computeAimAngle(){
      return Math.atan2((state.mouse.y + state.camera.y) - state.player.y, (state.mouse.x + state.camera.x) - state.player.x);
    }

    // ================== GAME LOOP ==================
    function step(ts){
      if (!state.running) return; requestAnimationFrame(step);
      state.dt = Math.min(0.033, (ts - state.last)/1000 || 0.016); state.last = ts; state.t += state.dt;

      // INPUT
      let ax=0, ay=0;
      if (state.keys.has('KeyW') || state.keys.has('ArrowUp')) ay -= 1;
      if (state.keys.has('KeyS') || state.keys.has('ArrowDown')) ay += 1;
      if (state.keys.has('KeyA') || state.keys.has('ArrowLeft')) ax -= 1;
      if (state.keys.has('KeyD') || state.keys.has('ArrowRight')) ax += 1;
      let aimAngle = computeAimAngle();

      const gp = readGamepad();
      if (gp){
        const dead = 0.2; const lx = Math.abs(gp.axes[0])>dead ? gp.axes[0] : 0; const ly = Math.abs(gp.axes[1])>dead ? gp.axes[1] : 0;
        const rx = Math.abs(gp.axes[2])>dead ? gp.axes[2] : 0; const ry = Math.abs(gp.axes[3])>dead ? gp.axes[3] : 0;
        ax = lx; ay = ly; if (rx||ry) aimAngle = Math.atan2(ry, rx);
        const rt = gp.buttons[7]?.value || 0; if (rt>0.3) tryShoot(aimAngle);
        if (gp.buttons[0]?.pressed) tryInteract();
      }

      // PLAYER UPDATE
      const p = state.player; if (!p) return;
      const mag = Math.hypot(ax,ay) || 1; const vx = (ax/mag)*p.speed; const vy = (ay/mag)*p.speed;
      moveWithColliders(p, vx, vy);

      p.dir = aimAngle; if (state.mouse.down) tryShoot(p.dir);

      // Timers
      if (p.reloading){
        p.reloadT -= state.dt; const w = state.weapons[state.weaponIndex];
        const elapsed = w.reload - Math.max(0,p.reloadT);
        document.getElementById('reloadBar').style.width = Math.round((elapsed / w.reload)*100) + '%';
        if (p.reloadT<=0) finishReload();
      }
      p.fireCd = Math.max(0, p.fireCd - state.dt);

      // Bullets
      for (let i=state.bullets.length-1;i>=0;i--){
        const b = state.bullets[i]; b.life -= state.dt; if (b.life<=0){ state.bullets.splice(i,1); continue; }
        b.x += b.vx*state.dt; b.y += b.vy*state.dt;
        for (const w of state.walls){ if (b.x> w.x && b.x< w.x+w.w && b.y> w.y && b.y< w.y+w.h){ state.bullets.splice(i,1); continue; } }
        if (b.friendly){
          for (let j=state.enemies.length-1;j>=0;j--){ const e = state.enemies[j]; if (Math.hypot(e.x-b.x, e.y-b.y) < e.r){ e.hp -= b.dmg; state.bullets.splice(i,1); if (e.hp<=0) state.enemies.splice(j,1); break; } }
        } else {
          if (Math.hypot(p.x-b.x, p.y-b.y) < p.r){ p.hp -= b.dmg; state.bullets.splice(i,1); if (p.hp<=0) gameOver(false); }
        }
      }

      // Enemies
      for (const e of state.enemies) updateEnemy(e);

      // Intel
      if (!state.intel.taken && dist(p, state.intel) < p.r + state.intel.r){ state.intel.taken=true; p.hasIntel=true; document.getElementById('intelText').textContent = `1 / 1`; state.extractZone.active=true; document.getElementById('extractMsg').style.display='block'; toast('Intel secured. Head to extract!'); }

      // Extract
      if (state.extractZone.active && p.x>state.extractZone.x && p.x<state.extractZone.x+state.extractZone.w && p.y>state.extractZone.y && p.y<state.extractZone.y+state.extractZone.h){ if (p.hasIntel) gameOver(true); }

      // Noise
      state.noise = Math.max(0, state.noise - state.dt*0.15);

      // Camera with deadzone
      const DZ_W = W * 0.45, DZ_H = H * 0.45;
      const dzLeft = state.camera.x + (W - DZ_W)/2;
      const dzRight = dzLeft + DZ_W;
      const dzTop = state.camera.y + (H - DZ_H)/2;
      const dzBottom = dzTop + DZ_H;
      if (p.x < dzLeft) state.camera.x = clamp(p.x - DZ_W/2, 0, state.world.w - W);
      else if (p.x > dzRight) state.camera.x = clamp(p.x + DZ_W/2 - W, 0, state.world.w - W);
      if (p.y < dzTop) state.camera.y = clamp(p.y - DZ_H/2, 0, state.world.h - H);
      else if (p.y > dzBottom) state.camera.y = clamp(p.y + DZ_H/2 - H, 0, state.world.h - H);

      // Render
      const mouseWorld = { x: state.mouse.x + state.camera.x, y: state.mouse.y + state.camera.y };
      const hasLOS = lineOfSight(p, mouseWorld, state.walls);
      draw(hasLOS);

      // HUD
      document.getElementById('hpBar').style.width = clamp(p.hp,0,100) + '%';
      document.getElementById('noiseBar').style.width = Math.round(state.noise*100) + '%';
      document.getElementById('enemyText').textContent = state.enemies.length.toString();
    }

    function draw(hasLOS){
      const cam = state.camera; ctx.clearRect(0,0,W,H);
      ctx.save(); ctx.translate(-cam.x, -cam.y);

      // Grid
      ctx.fillStyle = '#0a122b'; ctx.fillRect(cam.x, cam.y, W, H);
      ctx.strokeStyle = '#0f1a3a'; ctx.lineWidth = 1;
      for (let x=0; x<state.world.w; x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,state.world.h); ctx.stroke(); }
      for (let y=0; y<state.world.h; y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(state.world.w,y); ctx.stroke(); }

      // Walls
      ctx.fillStyle = '#15214a'; ctx.strokeStyle = '#29408a';
      for (const w of state.walls){ ctx.fillRect(w.x,w.y,w.w,w.h); ctx.strokeRect(w.x+0.5,w.y+0.5,w.w-1,w.h-1); }

      // Extract zone
      if (state.extractZone.active){ const z = state.extractZone; ctx.fillStyle = 'rgba(0,255,120,0.12)'; ctx.fillRect(z.x, z.y, z.w, z.h); ctx.strokeStyle = '#3cff95'; ctx.strokeRect(z.x+0.5, z.y+0.5, z.w-1, z.h-1); }

      // Intel
      if (!state.intel.taken){ ctx.beginPath(); ctx.arc(state.intel.x, state.intel.y, state.intel.r, 0, TAU); ctx.fillStyle = '#3bd1ff'; ctx.fill(); ctx.strokeStyle = '#7be0ff'; ctx.stroke(); }

      // Bullets
      ctx.strokeStyle = '#a6bfff'; ctx.lineWidth = 2;
      for (const b of state.bullets){ ctx.beginPath(); ctx.moveTo(b.x, b.y); ctx.lineTo(b.x - b.vx*0.02, b.y - b.vy*0.02); ctx.stroke(); }

      // Player & Enemies
      const p = state.player; drawSoldier(p.x, p.y, p.dir, '#7cff6b');
      for (const e of state.enemies){ drawSoldier(e.x, e.y, e.angle, '#ff6b6b'); }

      ctx.restore();

      // Minimap
      drawMinimap();

      // Crosshair in screen space
      const cx = state.mouse.x, cy = state.mouse.y; ctx.save(); ctx.translate(cx, cy);
      ctx.strokeStyle = hasLOS ? '#7cff6b' : '#ff6b6b'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(-10,0); ctx.lineTo(-2,0); ctx.moveTo(2,0); ctx.lineTo(10,0); ctx.moveTo(0,-10); ctx.lineTo(0,-2); ctx.moveTo(0,2); ctx.lineTo(0,10); ctx.stroke();
      ctx.beginPath(); ctx.arc(0,0, 3, 0, TAU); ctx.stroke(); ctx.restore();
    }

    function drawSoldier(x,y,angle,color){ ctx.save(); ctx.translate(x, y); ctx.rotate(angle); ctx.fillStyle = color; ctx.beginPath(); ctx.arc(0,0, 14, 0, TAU); ctx.fill(); ctx.fillStyle = '#0a0f20'; ctx.beginPath(); ctx.arc(0,0, 8, 0, TAU); ctx.fill(); ctx.fillStyle = color; ctx.fillRect(2, -3, 16, 6); ctx.restore(); }

    function drawMinimap(){
      const scaleX = mini.width / state.world.w; const scaleY = mini.height / state.world.h;
      mctx.clearRect(0,0,mini.width,mini.height);
      mctx.fillStyle = '#0b1330'; mctx.fillRect(0,0,mini.width,mini.height);
      mctx.fillStyle = '#1a2b60'; for (const w of state.walls){ mctx.fillRect(w.x*scaleX, w.y*scaleY, w.w*scaleX, w.h*scaleY);} 
      if (state.extractZone.active){ const z = state.extractZone; mctx.strokeStyle = '#3cff95'; mctx.strokeRect(z.x*scaleX+0.5, z.y*scaleY+0.5, z.w*scaleX-1, z.h*scaleY-1); }
      if (!state.intel.taken){ mctx.fillStyle = '#3bd1ff'; mctx.fillRect(state.intel.x*scaleX-2, state.intel.y*scaleY-2, 4, 4); }
      mctx.fillStyle = '#ff6b6b'; for (const e of state.enemies){ mctx.fillRect(e.x*scaleX-1, e.y*scaleY-1, 2, 2);} 
      mctx.fillStyle = '#7cff6b'; const p = state.player; mctx.fillRect(p.x*scaleX-2, p.y*scaleY-2, 4, 4);
    }

    function tryInteract(){ const p = state.player; if (!state.intel.taken && dist(p, state.intel) < p.r + state.intel.r + 4){ state.intel.taken=true; p.hasIntel=true; document.getElementById('intelText').textContent = `1 / 1`; state.extractZone.active=true; document.getElementById('extractMsg').style.display='block'; toast('Intel secured. Head to extract!'); } }

    function gameOver(won){ state.running=false; state.won=won; document.getElementById('menu').style.display='grid'; const t=document.querySelector('#menu .subtitle'); t.innerHTML = won? 'Extraction complete. Mission success. <strong>Play again?</strong>':'You were neutralized. <strong>Retry?</strong>'; }

    // ================== UI BINDINGS ==================
    document.getElementById('startBtn').addEventListener('click', ()=>{ setupLevel(); state.running=true; state.last=performance.now(); document.getElementById('menu').style.display='none'; canvas.focus(); requestAnimationFrame(step); });
    document.getElementById('howBtn').addEventListener('click', ()=>{ toast('Secure the Intel (blue), then reach the green extraction zone near spawn. Avoid patrols; shoot sparingly to keep noise low.'); });
    document.getElementById('gpBtn').addEventListener('click', ()=>{ const gp = readGamepad(); if (gp){ toast('Controller active. Left stick move, right stick aim, RT shoot, A interact.'); } else { toast('Press any button on your controller.'); } });

    // ================== DEV TESTS ==================
    function runTests(){
      const results = [];
      function t(name, fn){ try{ fn(); results.push(['PASS', name]); } catch(err){ console.error(err); results.push(['FAIL', name+': '+err.message]); } }

      // Test 1: reload math
      t('Reload fills up to mag and reduces reserve', ()=>{
        const w = {mag:30}; const a = {mag:12, reserve:17};
        const needed = w.mag - a.mag; const take = Math.min(needed, a.reserve);
        if (take !== 17) throw new Error('expected take=17');
      });

      // Test 2: aim angle world-space
      t('Aim computed in world space accounts for camera', ()=>{
        state.camera.x = 100; state.camera.y = 50; state.player = {x:200,y:200}; state.mouse = {x:100,y:150};
        const ang = computeAimAngle();
        const dx = (state.mouse.x+state.camera.x) - state.player.x;
        const dy = (state.mouse.y+state.camera.y) - state.player.y;
        if (Math.abs(Math.atan2(dy,dx) - ang) > 1e-9) throw new Error('angle mismatch');
      });

      // Test 3: move clamps world bounds
      t('moveWithColliders clamps to world', ()=>{
        const obj = {x:2190,y:1390,r:14}; const beforeX = obj.x;
        state.dt = 0.016; moveWithColliders(obj, 1000, 1000);
        if (obj.x > state.world.w-obj.r || obj.y > state.world.h-obj.r) throw new Error('did not clamp');
        if (obj.x < beforeX) throw new Error('unexpected left move');
      });

      // Test 4: shootFrom adds bullet
      t('shootFrom spawns bullet + noise', ()=>{
        const bulletsBefore = state.bullets.length; const n0 = state.noise;
        shootFrom({x:10,y:10,r:5}, 0, true, {speed:800, spread:0, dmg:10});
        if (state.bullets.length !== bulletsBefore+1) throw new Error('no bullet');
        if (state.noise <= n0) throw new Error('noise did not increase');
      });

      const fails = results.filter(r=>r[0]==='FAIL');
      if (fails.length){ toast('Tests: '+fails.length+' failed — check console'); }
      else { console.log('All tests passed'); }
    }

    // Init first frame for minimap visibility, run tests
    setupLevel(); runTests(); draw(false);
  })();
  </script>
</body>
</html>
